from dulwich.config import Config as Config, get_xdg_config_home_path as get_xdg_config_home_path
from dulwich.repo import Repo as Repo
from typing import Any, BinaryIO, Iterable, List, Optional, Union

def translate(pat: bytes) -> bytes: ...
def read_ignore_patterns(f: BinaryIO) -> Iterable[bytes]: ...
def match_pattern(path: bytes, pattern: bytes, ignorecase: bool=...) -> bool: ...

class Pattern:
    pattern: Any = ...
    ignorecase: Any = ...
    is_exclude: bool = ...
    def __init__(self, pattern: bytes, ignorecase: bool=...) -> None: ...
    def __bytes__(self) -> bytes: ...
    def __eq__(self, other: object) -> bool: ...
    def match(self, path: bytes) -> bool: ...

class IgnoreFilter:
    def __init__(self, patterns: Iterable[bytes], ignorecase: bool=..., path: Any=...) -> None: ...
    def append_pattern(self, pattern: bytes) -> None: ...
    def find_matching(self, path: Union[bytes, str]) -> Iterable[Pattern]: ...
    def is_ignored(self, path: bytes) -> Optional[bool]: ...
    @classmethod
    def from_path(cls: Any, path: Any, ignorecase: bool=...) -> IgnoreFilter: ...

class IgnoreFilterStack:
    def __init__(self, filters: Any) -> None: ...
    def is_ignored(self, path: str) -> Optional[bool]: ...

def default_user_ignore_filter_path(config: Config) -> str: ...

class IgnoreFilterManager:
    def __init__(self, top_path: str, global_filters: List[IgnoreFilter], ignorecase: bool) -> None: ...
    def find_matching(self, path: str) -> Iterable[Pattern]: ...
    def is_ignored(self, path: str) -> Optional[bool]: ...
    @classmethod
    def from_repo(cls: Any, repo: Repo) -> IgnoreFilterManager: ...
