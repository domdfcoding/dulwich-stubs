# object_store.py -- Object store for git objects
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@jelmer.uk>
#                         and others
#
# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU
# General Public License as public by the Free Software Foundation; version 2.0
# or (at your option) any later version. You can redistribute it and/or
# modify it under the terms of either of these two licenses.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# You should have received a copy of the licenses; if not, see
# <http://www.gnu.org/licenses/> for a copy of the GNU General Public License
# and <http://www.apache.org/licenses/LICENSE-2.0> for a copy of the Apache
# License, Version 2.0.
#

# stdlib
from typing import IO, Any, Callable, Iterable, Iterator, Optional, Tuple

# this package
from dulwich.objects import TreeEntry

INFODIR: str
PACKDIR: str

class BaseObjectStore:
	def determine_wants_all(self, refs: Any): ...
	def iter_shas(self, shas: Iterable[Any]) -> ObjectStoreIterator: ...
	def contains_loose(self, sha: Any) -> None: ...
	def contains_packed(self, sha: Any) -> None: ...
	def __contains__(self, sha: Any): ...

	@property
	def packs(self) -> None: ...

	def get_raw(self, name: Any) -> Tuple: ...
	def __getitem__(self, sha: Any): ...
	def __iter__(self) -> Any: ...
	def add_object(self, obj: Any) -> None: ...
	def add_objects(self, objects: Any, progress: Optional[Any] = ...) -> None: ...
	def add_pack_data(self, count: int, pack_data: Iterable[Any], progress: Optional[Any] = ...): ...

	def tree_changes(
			self,
			source: Any,
			target: Any,
			want_unchanged: bool = ...,
			include_trees: bool = ...,
			change_type_same: bool = ...,
			rename_detector: Optional[Any] = ...,
			) -> None: ...

	def iter_tree_contents(self, tree_id: Any, include_trees: bool = ...) -> Iterator[TreeEntry]: ...

	def find_missing_objects(
			self,
			haves: Any,
			wants: Any,
			shallow: Optional[Any] = ...,
			progress: Optional[Any] = ...,
			get_tagged: Optional[Any] = ...,
			get_parents: Any = ...,
			depth: Optional[Any] = ...,
			) -> Iterator[Any]: ...

	def find_common_revisions(self, graphwalker: Any): ...

	def generate_pack_contents(
			self,
			have: Any,
			want: Any,
			shallow: Optional[Any] = ...,
			progress: Optional[Any] = ...,
			): ...

	def generate_pack_data(
			self,
			have: Any,
			want: Any,
			shallow: Optional[Any] = ...,
			progress: Optional[Any] = ...,
			ofs_delta: bool = ...,
			): ...

	def peel_sha(self, sha: Any): ...
	def close(self) -> None: ...

class PackBasedObjectStore(BaseObjectStore):
	pack_compression_level: Any = ...

	def __init__(self, pack_compression_level: int = ...) -> None: ...

	@property
	def alternates(self): ...

	def contains_packed(self, sha: Any): ...
	def __contains__(self, sha: Any): ...
	def close(self) -> None: ...

	@property
	def packs(self): ...

	def pack_loose_objects(self) -> int: ...
	def repack(self) -> int: ...
	def __iter__(self) -> Any: ...
	def contains_loose(self, sha: Any): ...
	def get_raw(self, name: Any) -> Tuple[Any, Any]: ...
	def add_objects(self, objects: Any, progress: Optional[Any] = ...): ...

class DiskObjectStore(PackBasedObjectStore):
	path: Any = ...
	pack_dir: Any = ...
	loose_compression_level: Any = ...
	pack_compression_level: Any = ...

	def __init__(self, path: Any, loose_compression_level: int = ..., pack_compression_level: int = ...) -> None: ...

	@classmethod
	def from_config(cls, path: Any, config: Any): ...

	@property
	def alternates(self): ...

	def add_alternate_path(self, path: Any) -> None: ...
	def add_thin_pack(self, read_all: Callable, read_some: Callable): ...
	def move_in_pack(self, path: Any): ...
	def add_pack(self) -> Tuple[IO, Callable, Callable]: ...
	def add_object(self, obj: Any) -> None: ...

	@classmethod
	def init(cls, path: Any): ...

class MemoryObjectStore(BaseObjectStore):
	pack_compression_level: int = ...

	def __init__(self) -> None: ...
	def contains_loose(self, sha: Any): ...
	def contains_packed(self, sha: Any): ...
	def __iter__(self) -> Any: ...

	@property
	def packs(self): ...

	def get_raw(self, name: Any): ...
	def __getitem__(self, name: Any): ...
	def __delitem__(self, name: Any) -> None: ...
	def add_object(self, obj: Any) -> None: ...
	def add_objects(self, objects: Any, progress: Optional[Any] = ...) -> None: ...
	def add_pack(self) -> Tuple[IO, Callable, Callable]: ...
	def add_thin_pack(self, read_all: Any, read_some: Any) -> None: ...

class ObjectIterator:
	def iterobjects(self) -> None: ...

class ObjectStoreIterator(ObjectIterator):
	store: Any = ...
	sha_iter: Any = ...

	def __init__(self, store: Any, sha_iter: Any) -> None: ...
	def __iter__(self) -> Any: ...
	def iterobjects(self) -> None: ...
	def itershas(self) -> None: ...
	def __contains__(self, needle: Any): ...
	def __getitem__(self, key: Any): ...
	def __len__(self): ...
	def empty(self) -> bool: ...
	def __bool__(self): ...

def tree_lookup_path(lookup_obj: Any, root_sha: Any, path: Any): ...

class MissingObjectFinder:
	object_store: Any = ...
	sha_done: Any = ...
	objects_to_send: Any = ...
	progress: Any = ...

	def __init__(
			self,
			object_store: Any,
			haves: Any,
			wants: Any,
			shallow: Optional[Any] = ...,
			progress: Optional[Any] = ...,
			get_tagged: Optional[Any] = ...,
			get_parents: Any = ...,
			): ...

	def add_todo(self, entries: Any) -> None: ...
	def next(self): ...  # noqa: A003  # pylint: disable=redefined-builtin

	__next__: Any = ...

class ObjectStoreGraphWalker:
	heads: Any = ...
	get_parents: Any = ...
	parents: Any = ...
	shallow: Any = ...

	def __init__(self, local_heads: Any, get_parents: Any, shallow: Optional[Any] = ...) -> None: ...
	def ack(self, sha: Any) -> None: ...
	def next(self): ...  # noqa: A003  # pylint: disable=redefined-builtin

	__next__: Any = ...

def commit_tree_changes(object_store: Any, tree: Any, changes: Any): ...

class OverlayObjectStore(BaseObjectStore):
	bases: Any = ...
	add_store: Any = ...

	def __init__(self, bases: Any, add_store: Optional[Any] = ...) -> None: ...

	def add_object(
			self,
			object: Any,  # noqa: A002  # pylint: disable=redefined-builtin
			): ...

	def add_objects(self, objects: Any, progress: Optional[Any] = ...): ...

	@property
	def packs(self): ...

	def __iter__(self) -> Any: ...
	def get_raw(self, sha_id: Any): ...
	def contains_packed(self, sha: Any): ...
	def contains_loose(self, sha: Any): ...

def read_packs_file(f: Any) -> None: ...
