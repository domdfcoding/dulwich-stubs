# object_store.py -- Object store for git objects
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@jelmer.uk>
#                         and others
#
# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU
# General Public License as public by the Free Software Foundation; version 2.0
# or (at your option) any later version. You can redistribute it and/or
# modify it under the terms of either of these two licenses.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# You should have received a copy of the licenses; if not, see
# <http://www.gnu.org/licenses/> for a copy of the GNU General Public License
# and <http://www.apache.org/licenses/LICENSE-2.0> for a copy of the Apache
# License, Version 2.0.
#

from dulwich.diff_tree import tree_changes as tree_changes, walk_trees as walk_trees
from dulwich.errors import NotTreeError as NotTreeError
from dulwich.file import GitFile as GitFile
from dulwich.objects import (
    Commit as Commit, S_ISGITLINK as S_ISGITLINK, ShaFile as ShaFile, Tag as Tag, Tree as Tree,
    TreeEntry, ZERO_SHA as ZERO_SHA, hex_to_filename as hex_to_filename, hex_to_sha as hex_to_sha,
    object_class as object_class, sha_to_hex as sha_to_hex, valid_hexsha as valid_hexsha,
    )
from dulwich.pack import Pack as Pack, PackData as PackData, PackFileDisappeared as PackFileDisappeared, PackIndexer as PackIndexer, PackInflater as PackInflater, PackStreamCopier as PackStreamCopier, compute_file_sha as compute_file_sha, iter_sha1 as iter_sha1, pack_objects_to_data as pack_objects_to_data, write_pack_data as write_pack_data, write_pack_header as write_pack_header, write_pack_index_v2 as write_pack_index_v2, write_pack_object as write_pack_object
from dulwich.refs import ANNOTATED_TAG_SUFFIX as ANNOTATED_TAG_SUFFIX
from typing import Any, Callable, IO, Iterable, Iterator, Optional, Tuple

INFODIR: str
PACKDIR: str

class BaseObjectStore:
    def determine_wants_all(self, refs: Any): ...
    def iter_shas(self, shas: Iterable[Any]) -> ObjectStoreIterator: ...
    def contains_loose(self, sha: Any) -> None: ...
    def contains_packed(self, sha: Any) -> None: ...
    def __contains__(self, sha: Any): ...
    @property
    def packs(self) -> None: ...
    def get_raw(self, name: Any) -> Tuple: ...
    def __getitem__(self, sha: Any): ...
    def __iter__(self) -> Any: ...
    def add_object(self, obj: Any) -> None: ...
    def add_objects(self, objects: Any, progress: Optional[Any] = ...) -> None: ...
    def add_pack_data(self, count: int, pack_data: Iterable[Any], progress: Optional[Any] = ...): ...
    def tree_changes(self, source: Any, target: Any, want_unchanged: bool = ..., include_trees: bool = ..., change_type_same: bool = ..., rename_detector: Optional[Any] = ...) -> None: ...
    def iter_tree_contents(self, tree_id: Any, include_trees: bool = ...) -> Iterator[TreeEntry]: ...
    def find_missing_objects(self, haves: Any, wants: Any, shallow: Optional[Any] = ..., progress: Optional[Any] = ..., get_tagged: Optional[Any] = ..., get_parents: Any = ..., depth: Optional[Any] = ...) -> Iterator[Any]: ...
    def find_common_revisions(self, graphwalker: Any): ...
    def generate_pack_contents(self, have: Any, want: Any, shallow: Optional[Any] = ..., progress: Optional[Any] = ...): ...
    def generate_pack_data(self, have: Any, want: Any, shallow: Optional[Any] = ..., progress: Optional[Any] = ..., ofs_delta: bool = ...): ...
    def peel_sha(self, sha: Any): ...
    def close(self) -> None: ...

class PackBasedObjectStore(BaseObjectStore):
    pack_compression_level: Any = ...
    def __init__(self, pack_compression_level: int = ...) -> None: ...
    @property
    def alternates(self): ...
    def contains_packed(self, sha: Any): ...
    def __contains__(self, sha: Any): ...
    def close(self) -> None: ...
    @property
    def packs(self): ...
    def pack_loose_objects(self) -> int: ...
    def repack(self) -> int: ...
    def __iter__(self) -> Any: ...
    def contains_loose(self, sha: Any): ...
    def get_raw(self, name: Any) -> Tuple[Any, Any]: ...
    def add_objects(self, objects: Any, progress: Optional[Any] = ...): ...

class DiskObjectStore(PackBasedObjectStore):
    path: Any = ...
    pack_dir: Any = ...
    loose_compression_level: Any = ...
    pack_compression_level: Any = ...
    def __init__(self, path: Any, loose_compression_level: int = ..., pack_compression_level: int = ...) -> None: ...
    @classmethod
    def from_config(cls, path: Any, config: Any): ...
    @property
    def alternates(self): ...
    def add_alternate_path(self, path: Any) -> None: ...
    def add_thin_pack(self, read_all: Callable, read_some: Callable): ...
    def move_in_pack(self, path: Any): ...
    def add_pack(self) -> Tuple[IO, Callable, Callable]: ...
    def add_object(self, obj: Any) -> None: ...
    @classmethod
    def init(cls, path: Any): ...

class MemoryObjectStore(BaseObjectStore):
    pack_compression_level: int = ...
    def __init__(self) -> None: ...
    def contains_loose(self, sha: Any): ...
    def contains_packed(self, sha: Any): ...
    def __iter__(self) -> Any: ...
    @property
    def packs(self): ...
    def get_raw(self, name: Any): ...
    def __getitem__(self, name: Any): ...
    def __delitem__(self, name: Any) -> None: ...
    def add_object(self, obj: Any) -> None: ...
    def add_objects(self, objects: Any, progress: Optional[Any] = ...) -> None: ...
    def add_pack(self) -> Tuple[IO, Callable, Callable]: ...
    def add_thin_pack(self, read_all: Any, read_some: Any) -> None: ...

class ObjectIterator:
    def iterobjects(self) -> None: ...

class ObjectStoreIterator(ObjectIterator):
    store: Any = ...
    sha_iter: Any = ...
    def __init__(self, store: Any, sha_iter: Any) -> None: ...
    def __iter__(self) -> Any: ...
    def iterobjects(self) -> None: ...
    def itershas(self) -> None: ...
    def __contains__(self, needle: Any): ...
    def __getitem__(self, key: Any): ...
    def __len__(self): ...
    def empty(self) -> bool: ...
    def __bool__(self): ...

def tree_lookup_path(lookup_obj: Any, root_sha: Any, path: Any): ...

class MissingObjectFinder:
    object_store: Any = ...
    sha_done: Any = ...
    objects_to_send: Any = ...
    progress: Any = ...
    def __init__(self, object_store: Any, haves: Any, wants: Any, shallow: Optional[Any] = ..., progress: Optional[Any] = ..., get_tagged: Optional[Any] = ..., get_parents: Any = ...): ...
    def add_todo(self, entries: Any) -> None: ...
    def next(self): ...
    __next__: Any = ...

class ObjectStoreGraphWalker:
    heads: Any = ...
    get_parents: Any = ...
    parents: Any = ...
    shallow: Any = ...
    def __init__(self, local_heads: Any, get_parents: Any, shallow: Optional[Any] = ...) -> None: ...
    def ack(self, sha: Any) -> None: ...
    def next(self): ...
    __next__: Any = ...

def commit_tree_changes(object_store: Any, tree: Any, changes: Any): ...

class OverlayObjectStore(BaseObjectStore):
    bases: Any = ...
    add_store: Any = ...
    def __init__(self, bases: Any, add_store: Optional[Any] = ...) -> None: ...
    def add_object(self, object: Any): ...
    def add_objects(self, objects: Any, progress: Optional[Any] = ...): ...
    @property
    def packs(self): ...
    def __iter__(self) -> Any: ...
    def get_raw(self, sha_id: Any): ...
    def contains_packed(self, sha: Any): ...
    def contains_loose(self, sha: Any): ...

def read_packs_file(f: Any) -> None: ...
