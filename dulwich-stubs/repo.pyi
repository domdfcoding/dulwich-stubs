# repo.py -- For dealing with git repositories.
# Copyright (C) 2007 James Westby <jw+debian@jameswestby.net>
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@jelmer.uk>
#
# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU
# General Public License as public by the Free Software Foundation; version 2.0
# or (at your option) any later version. You can redistribute it and/or
# modify it under the terms of either of these two licenses.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# You should have received a copy of the licenses; if not, see
# <http://www.gnu.org/licenses/> for a copy of the GNU General Public License
# and <http://www.apache.org/licenses/LICENSE-2.0> for a copy of the Apache
# License, Version 2.0.
#
import os
from io import BytesIO

from dulwich.config import ConfigFile as ConfigFile, StackedConfig as StackedConfig
from dulwich.diff_tree import RenameDetector
from dulwich.errors import CommitError as CommitError, HookError as HookError, NoIndexPresent as NoIndexPresent, NotBlobError as NotBlobError, NotCommitError as NotCommitError, NotGitRepository as NotGitRepository, NotTagError as NotTagError, NotTreeError as NotTreeError, RefFormatError as RefFormatError
from dulwich.file import GitFile as GitFile
from dulwich.hooks import CommitMsgShellHook as CommitMsgShellHook, Hook as Hook, PostCommitShellHook as PostCommitShellHook, PostReceiveShellHook as PostReceiveShellHook, PreCommitShellHook as PreCommitShellHook
from dulwich.index import Index as Index
from dulwich.line_ending import BlobNormalizer as BlobNormalizer
from dulwich.object_store import (
    BaseObjectStore as BaseObjectStore, DiskObjectStore as DiskObjectStore,
    MemoryObjectStore as MemoryObjectStore, ObjectStoreGraphWalker as ObjectStoreGraphWalker, ObjectStoreIterator,
    )
from dulwich.objects import Blob as Blob, Commit as Commit, ShaFile as ShaFile, Tag as Tag, Tree as Tree, check_hexsha as check_hexsha, valid_hexsha as valid_hexsha
from dulwich.pack import pack_objects_to_data as pack_objects_to_data
from dulwich.refs import ANNOTATED_TAG_SUFFIX as ANNOTATED_TAG_SUFFIX, DictRefsContainer as DictRefsContainer, DiskRefsContainer as DiskRefsContainer, InfoRefsContainer as InfoRefsContainer, RefsContainer as RefsContainer, SYMREF as SYMREF, check_ref_format as check_ref_format, read_packed_refs as read_packed_refs, read_packed_refs_with_peeled as read_packed_refs_with_peeled, write_packed_refs as write_packed_refs
from typing import (
    Any, AnyStr, Callable, Dict, IO, Iterable, Iterator, List, NoReturn, Optional, Set, Tuple, Type,
    Union,
    )

from dulwich.walk import Walker

CONTROLDIR: str
OBJECTDIR: str
REFSDIR: str
REFSDIR_TAGS: str
REFSDIR_HEADS: str
INDEX_FILENAME: str
COMMONDIR: str
GITDIR: str
WORKTREES: str
BASE_DIRECTORIES: List[List[str]]
DEFAULT_REF: bytes

class InvalidUserIdentity(Exception):
    identity: Any = ...
    def __init__(self, identity: Any) -> None: ...

def get_user_identity(config: StackedConfig, kind: Optional[str]=...) -> bytes: ...
def check_user_identity(identity: bytes) -> None: ...
def parse_graftpoints(graftpoints: Iterable[bytes]) -> Dict[bytes, List[bytes]]: ...
def serialize_graftpoints(graftpoints: Dict[bytes, List[bytes]]) -> bytes: ...

class ParentsProvider:
    store: Any = ...
    grafts: Dict = ...
    shallows: Set = ...
    def __init__(self, store: Any, grafts: Dict = ..., shallows: Iterable = ...) -> None: ...
    def get_parents(self, commit_id: Any, commit: Optional[Any] = ...): ...

class BaseRepo:
    object_store: BaseObjectStore = ...
    refs: RefsContainer = ...
    hooks: Dict[str, Hook] = ...
    def __init__(self, object_store: BaseObjectStore, refs: RefsContainer) -> None: ...
    def get_named_file(self, path: Any) -> Optional[IO]: ...
    def open_index(self) -> None: ...
    def fetch(self, target: Any, determine_wants: Optional[Callable] = ..., progress: Optional[Callable] = ..., depth: Optional[int] = ...) -> Dict[bytes, bytes]: ...
    def fetch_pack_data(self, determine_wants: Callable, graph_walker: Callable, progress: Callable, get_tagged: Optional[Callable] = ..., depth: Optional[int] = ...) -> Tuple[int, Iterator[Tuple[Any, Any, Any, Any]]]: ...
    def fetch_objects(self, determine_wants: Callable, graph_walker: Callable, progress: Callable, get_tagged: Optional[Callable] = ..., depth: Optional[int] = ...) -> ObjectStoreIterator: ...
    def generate_pack_data(self, have: List[AnyStr], want: List[AnyStr], progress: Optional[Callable] = ..., ofs_delta: Optional[Any] = ...): ...
    def get_graph_walker(self, heads: Optional[Any] = ...) -> ObjectStoreGraphWalker: ...
    def get_refs(self) -> Dict[bytes, bytes]: ...
    def head(self) -> bytes: ...
    def get_object(self, sha: bytes) -> ShaFile: ...
    def parents_provider(self): ...
    def get_parents(self, sha: bytes, commit: Commit=...) -> List[bytes]: ...
    def get_config(self) -> None: ...
    def get_description(self) -> None: ...
    def set_description(self, description: AnyStr) -> None: ...
    def get_config_stack(self) -> StackedConfig: ...
    def get_shallow(self) -> Set[AnyStr]: ...
    def update_shallow(self, new_shallow: Any, new_unshallow: Any) -> None: ...
    def get_peeled(self, ref: Any) -> AnyStr: ...
    def get_walker(
            self,
            include: Optional[Iterable[AnyStr]] = ...,
            exclude: Optional[Iterable[AnyStr]] = ...,
            order: str = ...,
            reverse: bool = ...,
            max_entries: Optional[int] = ...,
            paths: Optional[Iterable[AnyStr]] = ...,
            rename_detector: Optional[RenameDetector] = ...,
            follow: bool = ...,
            since: Optional[float] = ...,
            until: Optional[float] = ...,
            get_parents: Callable[[Any], Any] = ...,
            queue_cls: Type = ...,
            ) -> Walker: ...
    def __getitem__(self, name: Any) -> ShaFile: ...
    def __contains__(self, name: bytes) -> bool: ...
    def __setitem__(self, name: bytes, value: Union[ShaFile, bytes]) -> Any: ...
    def __delitem__(self, name: bytes) -> None: ...
    def do_commit(self, message: Optional[AnyStr] = ..., committer: Optional[AnyStr] = ..., author: Optional[AnyStr] = ..., commit_timestamp: Optional[float] = ..., commit_timezone: Optional[float] = ..., author_timestamp: Optional[float] = ..., author_timezone: Optional[float] = ..., tree: Optional[Any] = ..., encoding: Optional[AnyStr] = ..., ref: bytes = ..., merge_heads: Optional[Any] = ...) -> bytes: ...

def read_gitfile(f: IO) -> str: ...

class UnsupportedVersion(Exception):
    version: Any = ...
    def __init__(self, version: Any) -> None: ...

class Repo(BaseRepo):
    bare: bool = ...
    path: Any = ...
    def __init__(self, root: Union[str, os.PathLike]) -> None: ...
    @classmethod
    def discover(cls, start: str = ...): ...
    def controldir(self): ...
    def commondir(self): ...
    def get_named_file(self, path: AnyStr, basedir: Optional[AnyStr] = ...) -> Optional[IO]: ...
    def index_path(self) -> str: ...
    def open_index(self) -> Index: ...
    def has_index(self) -> bool: ...
    def stage(self, fs_paths: Union[List[str], str]) -> None: ...
    def clone(self, target_path: AnyStr, mkdir: bool = ..., bare: bool = ..., origin: bytes = ..., checkout: Optional[Any] = ...) -> "Repo": ...
    def reset_index(self, tree: Optional[Any] = ...): ...
    def get_config(self) -> ConfigFile: ...
    def get_description(self) -> Optional[AnyStr]: ...
    def set_description(self, description: Any) -> None: ...
    @classmethod
    def init(cls, path: Any, mkdir: bool = ...) -> "Repo": ...
    @classmethod
    def init_bare(cls, path: Any, mkdir: bool = ...) -> "Repo": ...
    create: Any = ...
    def close(self) -> None: ...
    def __enter__(self) -> "Repo": ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def get_blob_normalizer(self) -> BlobNormalizer: ...

class MemoryRepo(BaseRepo):
    bare: bool = ...
    def __init__(self) -> None: ...
    def set_description(self, description: Any) -> None: ...
    def get_description(self): ...
    def get_named_file(self, path: Any, basedir: Optional[Any] = ...) -> Optional[BytesIO]: ...
    def open_index(self) -> NoReturn: ...
    def get_config(self) -> ConfigFile: ...
    @classmethod
    def init_bare(cls, objects: Any, refs: Any) -> "MemoryRepo": ...
