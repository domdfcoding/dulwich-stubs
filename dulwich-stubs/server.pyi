# server.py -- Implementation of the server side git protocols
# Copyright (C) 2008 John Carr <john.carr@unrouted.co.uk>
# Coprygith (C) 2011-2012 Jelmer Vernooij <jelmer@jelmer.uk>
#
# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU
# General Public License as public by the Free Software Foundation; version 2.0
# or (at your option) any later version. You can redistribute it and/or
# modify it under the terms of either of these two licenses.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# You should have received a copy of the licenses; if not, see
# <http://www.gnu.org/licenses/> for a copy of the GNU General Public License
# and <http://www.apache.org/licenses/LICENSE-2.0> for a copy of the Apache
# License, Version 2.0.
#

# stdlib
import socketserver
from logging import Logger
from typing import IO, Any, AnyStr, Callable, Dict, Iterable, List, Optional, Set, Tuple, Type

# this package
from dulwich.objects import Commit
from dulwich.repo import BaseRepo, Repo

logger: Logger

class Backend:
	def open_repository(self, path: str) -> BaseRepo: ...

class BackendRepo:
	object_store: Any = ...
	refs: Any = ...

	def get_refs(self) -> Dict[bytes, bytes]: ...
	def get_peeled(self, name: bytes) -> Optional[bytes]: ...

	def fetch_objects(
			self,
			determine_wants: Any,
			graph_walker: Any,
			progress: Callable,
			get_tagged: Optional[Callable] = ...,
			) -> None: ...

class DictBackend(Backend):
	repos: Any = ...

	def __init__(self, repos: Any) -> None: ...
	def open_repository(self, path: str) -> BaseRepo: ...

class FileSystemBackend(Backend):
	root: Any = ...

	def __init__(self, root: Any = ...) -> None: ...
	def open_repository(self, path: str): ...

class Handler:
	backend: Any = ...
	proto: Any = ...
	stateless_rpc: Any = ...

	def __init__(self, backend: Any, proto: Any, stateless_rpc: Optional[Any] = ...) -> None: ...
	def handle(self) -> None: ...

class PackHandler(Handler):
	def __init__(self, backend: Any, proto: Any, stateless_rpc: Optional[Any] = ...) -> None: ...

	@classmethod
	def capability_line(cls, capabilities: Any) -> bytes: ...

	@classmethod
	def capabilities(cls: Any) -> Iterable[bytes]: ...

	@classmethod
	def innocuous_capabilities(cls: Any) -> Iterable[bytes]: ...

	@classmethod
	def required_capabilities(cls: Any) -> Iterable[bytes]: ...

	def set_client_capabilities(self, caps: Iterable[bytes]) -> None: ...
	def has_capability(self, cap: bytes) -> bool: ...
	def notify_done(self) -> None: ...

class UploadPackHandler(PackHandler):
	repo: Any = ...
	advertise_refs: Any = ...

	def __init__(
			self,
			backend: Any,
			args: Any,
			proto: Any,
			stateless_rpc: Optional[Any] = ...,
			advertise_refs: bool = ...,
			) -> None: ...

	@classmethod
	def capabilities(cls) -> List[bytes]: ...

	@classmethod
	def required_capabilities(cls) -> Tuple[bytes]: ...

	def progress(self, message: Any) -> None: ...
	def get_tagged(self, refs: Optional[Dict] = ..., repo: Optional[Repo] = ...) -> Dict: ...
	def handle(self) -> None: ...

class _ProtocolGraphWalker:
	handler: Any = ...
	store: Any = ...
	get_peeled: Any = ...
	get_symrefs: Any = ...
	proto: Any = ...
	stateless_rpc: Any = ...
	advertise_refs: Any = ...
	shallow: Any = ...
	client_shallow: Any = ...
	unshallow: Any = ...

	def __init__(self, handler: Any, object_store: Any, get_peeled: Any, get_symrefs: Any) -> None: ...
	def determine_wants(self, heads: Dict) -> List[AnyStr]: ...
	def unread_proto_line(self, command: Any, value: Any) -> None: ...
	def ack(self, have_ref: Any): ...
	def reset(self) -> None: ...
	def next(self): ...  # noqa: A003
	def __next__(self): ...
	def read_proto_line(self, allowed: Any): ...
	def notify_done(self) -> None: ...
	def send_ack(self, sha: AnyStr, ack_type: bytes = ...) -> None: ...
	def send_nak(self) -> None: ...
	def handle_done(self, done_required: Any, done_received: Any): ...
	def set_wants(self, wants: Any) -> None: ...
	def all_wants_satisfied(self, haves: Set[Commit]): ...
	def set_ack_type(self, ack_type: Any) -> None: ...

class SingleAckGraphWalkerImpl:
	walker: Any = ...

	def __init__(self, walker: Any) -> None: ...
	def ack(self, have_ref: Any) -> None: ...
	def next(self): ...  # noqa: A003
	def __next__(self): ...
	def handle_done(self, done_required: Any, done_received: Any): ...

class MultiAckGraphWalkerImpl:
	walker: Any = ...

	def __init__(self, walker: Any) -> None: ...
	def ack(self, have_ref: Any) -> None: ...
	def next(self): ...  # noqa: A003
	def __next__(self): ...
	def handle_done(self, done_required: Any, done_received: Any): ...

class MultiAckDetailedGraphWalkerImpl:
	walker: Any = ...

	def __init__(self, walker: Any) -> None: ...
	def ack(self, have_ref: Any) -> None: ...
	def next(self): ...  # noqa: A003
	def __next__(self): ...
	def handle_done(self, done_required: Any, done_received: Any): ...

class ReceivePackHandler(PackHandler):
	repo: Any = ...
	advertise_refs: Any = ...

	def __init__(
			self,
			backend: Any,
			args: Any,
			proto: Any,
			stateless_rpc: Optional[Any] = ...,
			advertise_refs: bool = ...,
			) -> None: ...

	@classmethod
	def capabilities(cls: Any) -> Iterable[bytes]: ...

	def handle(self) -> None: ...

class UploadArchiveHandler(Handler):
	repo: Any = ...

	def __init__(self, backend: Any, args: Any, proto: Any, stateless_rpc: Optional[Any] = ...) -> None: ...
	def handle(self): ...

DEFAULT_HANDLERS: Dict[bytes, Type[Handler]]

class TCPGitRequestHandler(socketserver.StreamRequestHandler):
	handlers: Any = ...

	def __init__(self, handlers: Any, *args: Any, **kwargs: Any) -> None: ...
	def handle(self) -> None: ...

class TCPGitServer(socketserver.TCPServer):
	allow_reuse_address: bool = ...
	serve: Callable = ...
	handlers: Dict[bytes, Type[Handler]] = ...
	backend: Any = ...

	def __init__(self, backend: Any, listen_addr: Any, port: int = ..., handlers: Optional[Any] = ...) -> None: ...
	def verify_request(self, request: Any, client_address: Any) -> bool: ...
	def handle_error(self, request: Any, client_address: Any) -> None: ...

def main(argv: List[str] = ...) -> None: ...

def serve_command(
		handler_cls: Type[Handler],
		argv: List[str] = ...,
		backend: Optional[Type[Backend]] = ...,
		inf: IO = ...,
		outf: IO = ...,
		) -> int: ...

def generate_info_refs(repo: Any): ...
def generate_objects_info_packs(repo: Any) -> None: ...
def update_server_info(repo: Any) -> None: ...
