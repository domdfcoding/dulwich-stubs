# repo.py -- For dealing with git repositories.
# Copyright (C) 2007 James Westby <jw+debian@jameswestby.net>
# Copyright (C) 2008-2013 Jelmer Vernooij <jelmer@jelmer.uk>
#
# Dulwich is dual-licensed under the Apache License, Version 2.0 and the GNU
# General Public License as public by the Free Software Foundation; version 2.0
# or (at your option) any later version. You can redistribute it and/or
# modify it under the terms of either of these two licenses.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# You should have received a copy of the licenses; if not, see
# <http://www.gnu.org/licenses/> for a copy of the GNU General Public License
# and <http://www.apache.org/licenses/LICENSE-2.0> for a copy of the Apache
# License, Version 2.0.
#

# stdlib
import os
from io import BytesIO
from typing import IO, Any, Callable, Dict, Iterable, Iterator, List, Optional, Set, Tuple, Type, TypeVar, Union

# 3rd party
from typing_extensions import NoReturn

# this package
from dulwich.config import ConfigFile, StackedConfig
from dulwich.diff_tree import RenameDetector
from dulwich.hooks import Hook
from dulwich.index import Index
from dulwich.line_ending import BlobNormalizer
from dulwich.object_store import BaseObjectStore, ObjectStoreGraphWalker, ObjectStoreIterator
from dulwich.objects import Commit, ShaFile
from dulwich.refs import RefsContainer
from dulwich.walk import Walker

CONTROLDIR: str
OBJECTDIR: str
REFSDIR: str
REFSDIR_TAGS: str
REFSDIR_HEADS: str
INDEX_FILENAME: str
COMMONDIR: str
GITDIR: str
WORKTREES: str
BASE_DIRECTORIES: List[List[str]]
DEFAULT_REF: bytes

class InvalidUserIdentity(Exception):
	identity: Any = ...

	def __init__(self, identity: Any) -> None: ...

def get_user_identity(config: StackedConfig, kind: Optional[str] = ...) -> bytes: ...
def check_user_identity(identity: bytes) -> None: ...
def parse_graftpoints(graftpoints: Iterable[bytes]) -> Dict[bytes, List[bytes]]: ...
def serialize_graftpoints(graftpoints: Dict[bytes, List[bytes]]) -> bytes: ...

class ParentsProvider:
	store: Any = ...
	grafts: Dict = ...
	shallows: Set = ...

	def __init__(self, store: Any, grafts: Dict = ..., shallows: Iterable = ...) -> None: ...
	def get_parents(self, commit_id: Any, commit: Optional[Any] = ...): ...

class BaseRepo:
	object_store: BaseObjectStore = ...
	refs: RefsContainer = ...
	hooks: Dict[str, Hook] = ...

	def __init__(self, object_store: BaseObjectStore, refs: RefsContainer) -> None: ...
	def get_named_file(self, path: Any) -> Optional[IO]: ...
	def open_index(self) -> Index: ...

	def fetch(
			self,
			target: Any,
			determine_wants: Optional[Callable] = ...,
			progress: Optional[Callable] = ...,
			depth: Optional[int] = ...,
			) -> Dict[bytes, bytes]: ...

	def fetch_pack_data(
			self,
			determine_wants: Callable,
			graph_walker: Callable,
			progress: Callable,
			get_tagged: Optional[Callable] = ...,
			depth: Optional[int] = ...,
			) -> Tuple[int, Iterator[Tuple[Any, Any, Any, Any]]]: ...

	def fetch_objects(
			self,
			determine_wants: Callable,
			graph_walker: Callable,
			progress: Callable,
			get_tagged: Optional[Callable] = ...,
			depth: Optional[int] = ...,
			) -> ObjectStoreIterator: ...

	def generate_pack_data(
			self,
			have: List[Union[str, bytes]],
			want: List[Union[str, bytes]],
			progress: Optional[Callable] = ...,
			ofs_delta: Optional[Any] = ...,
			): ...

	def get_graph_walker(self, heads: Optional[Any] = ...) -> ObjectStoreGraphWalker: ...
	def get_refs(self) -> Dict[bytes, bytes]: ...
	def head(self) -> bytes: ...
	def get_object(self, sha: bytes) -> ShaFile: ...
	def parents_provider(self): ...
	def get_parents(self, sha: bytes, commit: Optional[Commit] = ...) -> List[bytes]: ...
	def get_config(self) -> ConfigFile: ...
	def get_description(self) -> Optional[Union[str, bytes]]: ...
	def set_description(self, description: Union[str, bytes]) -> None: ...
	def get_config_stack(self) -> StackedConfig: ...
	def get_shallow(self) -> Set[Union[str, bytes]]: ...
	def update_shallow(self, new_shallow: Any, new_unshallow: Any) -> None: ...
	def get_peeled(self, ref: Any) -> Union[str, bytes]: ...

	def get_walker(
			self,
			include: Optional[Iterable[Union[str, bytes]]] = ...,
			exclude: Optional[Iterable[Union[str, bytes]]] = ...,
			order: str = ...,
			reverse: bool = ...,
			max_entries: Optional[int] = ...,
			paths: Optional[Iterable[Union[str, bytes]]] = ...,
			rename_detector: Optional[RenameDetector] = ...,
			follow: bool = ...,
			since: Optional[float] = ...,
			until: Optional[float] = ...,
			get_parents: Callable[[Any], Any] = ...,
			queue_cls: Type = ...,
			) -> Walker: ...

	def __getitem__(self, name: Any) -> ShaFile: ...
	def __contains__(self, name: bytes) -> bool: ...
	def __setitem__(self, name: bytes, value: Union[ShaFile, bytes]) -> Any: ...
	def __delitem__(self, name: bytes) -> None: ...

	def do_commit(
			self,
			message: Optional[Union[str, bytes]] = ...,
			committer: Optional[Union[str, bytes]] = ...,
			author: Optional[Union[str, bytes]] = ...,
			commit_timestamp: Optional[float] = ...,
			commit_timezone: Optional[float] = ...,
			author_timestamp: Optional[float] = ...,
			author_timezone: Optional[float] = ...,
			tree: Optional[Any] = ...,
			encoding: Optional[Union[str, bytes]] = ...,
			ref: bytes = ...,
			merge_heads: Optional[Any] = ...,
			no_verify: bool = ...,
			) -> bytes: ...

def read_gitfile(f: IO) -> str: ...

class UnsupportedVersion(Exception):
	version: Any = ...

	def __init__(self, version: Any) -> None: ...

_R = TypeVar("_R", bound="Repo")

class Repo(BaseRepo):
	bare: bool = ...
	path: Any = ...

	def __init__(self, root: Union[str, os.PathLike]) -> None: ...

	@classmethod
	def discover(cls, start: str = ...): ...

	def controldir(self): ...
	def commondir(self): ...
	def get_named_file(self, path: Union[str, bytes], basedir: Optional[Union[str, bytes]] = ...) -> Optional[IO]: ...
	def index_path(self) -> str: ...
	def open_index(self) -> Index: ...
	def has_index(self) -> bool: ...
	def stage(self, fs_paths: Union[List[str], str]) -> None: ...

	def clone(
			self,
			target_path: Union[str, bytes],
			mkdir: bool = ...,
			bare: bool = ...,
			origin: bytes = ...,
			checkout: Optional[Any] = ...,
			) -> _R: ...

	def reset_index(self, tree: Optional[Any] = ...): ...
	def get_config(self) -> ConfigFile: ...
	def get_description(self) -> Optional[Union[str, bytes]]: ...
	def set_description(self, description: Any) -> None: ...

	@classmethod
	def init(cls: Type[_R], path: Any, mkdir: bool = ...) -> _R: ...

	@classmethod
	def init_bare(cls: Type[_R], path: Any, mkdir: bool = ...) -> _R: ...

	create: Any = ...

	def close(self) -> None: ...
	def __enter__(self) -> _R: ...
	def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
	def get_blob_normalizer(self) -> BlobNormalizer: ...

_M = TypeVar("_M", bound="MemoryRepo")

class MemoryRepo(BaseRepo):
	bare: bool = ...

	def __init__(self) -> None: ...
	def set_description(self, description: Any) -> None: ...
	def get_description(self): ...
	def get_named_file(self, path: Any, basedir: Optional[Any] = ...) -> Optional[BytesIO]: ...
	def open_index(self) -> NoReturn: ...
	def get_config(self) -> ConfigFile: ...

	@classmethod
	def init_bare(cls, objects: Any, refs: Any) -> "_M": ...
